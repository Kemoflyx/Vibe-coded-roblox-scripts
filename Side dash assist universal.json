local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
local humanoid = character:WaitForChild("Humanoid")
local camera = workspace.CurrentCamera

local isActive = false
local lastETime = 0 

-- ── Settings ─────────────────────────────────────────────────────────────────
local CIRCLE_RADIUS = 5
local MAX_LOCK_DISTANCE = 500
local E_COOLDOWN = 2.0 

-- SPEEDS (Studs Per Second)
local SIDE_SPEED_SPS    = 127 
local FORWARD_SPEED_SPS = 107  
-- ─────────────────────────────────────────────────────────────────────────────

local targetCache = {}

local function addToCache(targetCharacter)
    if targetCharacter == character then return end 
    local targetRoot = targetCharacter:FindFirstChild("HumanoidRootPart") or targetCharacter:FindFirstChild("Torso") or targetCharacter:FindFirstChild("Head")
    local targetHumanoid = targetCharacter:FindFirstChildOfClass("Humanoid")
    
    if targetRoot and targetRoot:IsA("BasePart") and targetHumanoid then
        targetCache[targetCharacter] = { Root = targetRoot, Humanoid = targetHumanoid }
        return true
    end
    return false
end

local function setupPlayerTracking(targetPlayer)
    if targetPlayer == player then return end
    if targetPlayer.Character then addToCache(targetPlayer.Character) end
    targetPlayer.CharacterAdded:Connect(function(newChar) task.wait(0.5) addToCache(newChar) end)
end

local function getTargetClosestToCursor()
    local nearestTarget = nil
    local shortestMouseDist = math.huge
    local mousePos = UserInputService:GetMouseLocation()

    for char, targetData in pairs(targetCache) do
        if char.Parent and targetData.Humanoid.Health > 0 then
            local worldDist = (targetData.Root.Position - humanoidRootPart.Position).Magnitude
            if worldDist <= MAX_LOCK_DISTANCE then
                local screenPos, onScreen = camera:WorldToViewportPoint(targetData.Root.Position)
                if onScreen then
                    local distToCursor = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
                    if distToCursor < shortestMouseDist then
                        shortestMouseDist = distToCursor
                        nearestTarget = targetData.Root
                    end
                end
            end
        else targetCache[char] = nil end
    end
    return nearestTarget
end

local function performCustomMovement()
    if isActive or (tick() - lastETime < E_COOLDOWN) then return end
    
    local target = getTargetClosestToCursor()
    if not target then return end
    
    isActive = true
    lastETime = tick() 
    
    -- Fire Q immediately
    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Q, false, game)
    task.delay(0.05, function()
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Q, false, game)
    end)

    local speedSPS = UserInputService:IsKeyDown(Enum.KeyCode.W) and FORWARD_SPEED_SPS or SIDE_SPEED_SPS

    local startPos = humanoidRootPart.Position
    local targetPos = target.Position
    local flattenedTargetPos = Vector3.new(targetPos.X, startPos.Y, targetPos.Z)
    
    local dirToTarget = (flattenedTargetPos - startPos).Unit
    local baseSideVector = dirToTarget:Cross(Vector3.new(0, 1, 0)).Unit 
    
    local sideMultiplier = UserInputService:IsKeyDown(Enum.KeyCode.A) and -1 or 1
    local targetSidePosition = flattenedTargetPos + (baseSideVector * sideMultiplier * CIRCLE_RADIUS)
    
    local distance = (targetSidePosition - startPos).Magnitude
    local finalDuration = distance / speedSPS

    local startCFrame = humanoidRootPart.CFrame
    local goalCFrame = CFrame.new(targetSidePosition, flattenedTargetPos)
    
    local startTime = tick()
    local connection
    connection = RunService.Heartbeat:Connect(function()
        local elapsed = tick() - startTime
        local progress = math.min(elapsed / finalDuration, 1)
        
        -- Quad Out for snappy start
        local alpha = progress * (2 - progress)
        local currentLerp = startCFrame:Lerp(goalCFrame, alpha)
        
        -- ── THE "NO HOLD BACK" FIX ──
        -- We release control at 95%. This prevents the CFrame from 
        -- "locking" you in place at the destination while the 
        -- underlying dash is still trying to move you.
        if progress >= 0.95 then
            connection:Disconnect()
            isActive = false
            return
        end
        
        humanoidRootPart.CFrame = CFrame.new(
            currentLerp.Position.X, 
            startPos.Y, 
            currentLerp.Position.Z
        ) * currentLerp.Rotation
    end)
end

-- ── Listeners ────────────────────────────────────────────────────────────────

UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.KeyCode == Enum.KeyCode.E then performCustomMovement() end
end)

player.CharacterAdded:Connect(function(newChar)
    character = newChar
    humanoid = newChar:WaitForChild("Humanoid")
    humanoidRootPart = newChar:WaitForChild("HumanoidRootPart")
end)

Players.PlayerAdded:Connect(setupPlayerTracking)
for _, otherPlayer in ipairs(Players:GetPlayers()) do setupPlayerTracking(otherPlayer) end
workspace.DescendantAdded:Connect(function(desc) if desc:IsA("Humanoid") then task.wait(0.5) addToCache(desc.Parent) end end)
for _, child in ipairs(workspace:GetDescendants()) do if child:IsA("Model") and child:FindFirstChildOfClass("Humanoid") then addToCache(child) end end
