local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local VirtualInputManager = game:GetService("VirtualInputManager")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
local humanoid = character:WaitForChild("Humanoid")

local isActive = false
local currentTarget = nil

local DASH_DURATION = 0.3
local DASH_DURATION_CLOSE = 0.2
local CLOSE_RANGE_THRESHOLD = 25
local CIRCLE_RADIUS = 5
local MAX_LOCK_DISTANCE = 50

local targetCache = {} -- Stores {Root = part, Humanoid = humanoid}

local function addToCache(targetCharacter)
    if targetCharacter == character then return end -- Don't cache yourself
    
    local targetRoot = targetCharacter:FindFirstChild("HumanoidRootPart") or targetCharacter:FindFirstChild("Torso") or targetCharacter:FindFirstChild("Head")
    local targetHumanoid = targetCharacter:FindFirstChildOfClass("Humanoid")
    
    if targetRoot and targetRoot:IsA("BasePart") and targetHumanoid then
        local cacheEntry = {
            Root = targetRoot,
            Humanoid = targetHumanoid,
            Character = targetCharacter
        }
        
        targetCache[targetCharacter] = cacheEntry


        targetCharacter.AncestryChanged:Connect(function(_, parent)
            if not parent then
                targetCache[targetCharacter] = nil
            end
        end)


        targetHumanoid.Died:Connect(function()
            -- Keep the entry but mark as dead, will update on respawn
            if targetCache[targetCharacter] then
                targetCache[targetCharacter].Dead = true
            end
        end)
        
        return true
    end
    return false
end


local function removeFromCache(targetCharacter)
    targetCache[targetCharacter] = nil
end


local function setupPlayerTracking(targetPlayer)
    if targetPlayer == player then return end -- Don't track yourself
    

    if targetPlayer.Character then
        addToCache(targetPlayer.Character)
    end
    

    targetPlayer.CharacterAdded:Connect(function(newCharacter)

        for cachedChar, _ in pairs(targetCache) do
            if cachedChar.Parent == targetPlayer then
                targetCache[cachedChar] = nil
            end
        end
        

        addToCache(newCharacter)
    end)
    

    targetPlayer.AncestryChanged:Connect(function(_, parent)
        if not parent then
            for cachedChar, _ in pairs(targetCache) do
                if cachedChar.Parent == targetPlayer then
                    targetCache[cachedChar] = nil
                end
            end
        end
    end)
end


local function searchForNPCsRecursive(parent, depth)
    depth = depth or 0
    if depth > 5 then return 0 end -- Prevent infinite recursion
    
    local npcCount = 0
    
    for _, child in ipairs(parent:GetChildren()) do
        -- If it's a model with a humanoid, try to cache it
        if child:IsA("Model") then
            if addToCache(child) then
                npcCount = npcCount + 1
            end
        end
        

        if child:IsA("Folder") or child:IsA("Model") then
            npcCount = npcCount + searchForNPCsRecursive(child, depth + 1)
        end
    end
    
    return npcCount
end


local function scanForNPCs()
    local npcCount = 0
    

    local commonFolderNames = {
        "NPCs", "Enemies", "Mobs", "Dummies", "Characters", 
        "Monsters", "Bosses", "Entities", "AI", "Units", "Dummy", "NPC"
    }
    
    for _, folderName in ipairs(commonFolderNames) do
        local folder = workspace:FindFirstChild(folderName)
        if folder then
            local count = searchForNPCsRecursive(folder)
            npcCount = npcCount + count
            

            folder.ChildAdded:Connect(function(child)
                if child:IsA("Model") then
                    task.wait(0.1) -- Wait for parts to load
                    addToCache(child)
                end
            end)
        end
    end
    

    if npcCount == 0 then
        for _, child in ipairs(workspace:GetChildren()) do
            if child:IsA("Model") and child ~= character then
                local hasHumanoid = child:FindFirstChildOfClass("Humanoid")
                if hasHumanoid then
                    if addToCache(child) then
                        npcCount = npcCount + 1
                    end
                end
            end
        end
        

        workspace.ChildAdded:Connect(function(child)
            if child:IsA("Model") then
                task.wait(0.1)
                local hasHumanoid = child:FindFirstChildOfClass("Humanoid")
                if hasHumanoid then
                    addToCache(child)
                end
            end
        end)
    end
    
    return npcCount
end


local function simulateDashInput()
    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.D, false, game)
    task.wait(0.01)
    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Q, false, game)
    task.wait(0.05)
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Q, false, game)
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.D, false, game)
end


local function findNearestTarget()
    local nearestTarget = nil
    local shortestDistanceSquared = MAX_LOCK_DISTANCE * MAX_LOCK_DISTANCE
    local myPosition = humanoidRootPart.Position
    

    for _, targetData in pairs(targetCache) do

        if targetData.Root and targetData.Root.Parent and targetData.Humanoid and targetData.Humanoid.Health > 0 then

            local offset = targetData.Root.Position - myPosition
            local distanceSquared = offset.X * offset.X + offset.Y * offset.Y + offset.Z * offset.Z
            
            if distanceSquared < shortestDistanceSquared then
                shortestDistanceSquared = distanceSquared
                nearestTarget = targetData.Root
            end
        end
    end
    
    return nearestTarget
end


local function performSideDash()
    if isActive then return end
    
    currentTarget = findNearestTarget()
    if not currentTarget then
        return
    end
    
    isActive = true
    

    simulateDashInput()
    

    local startPos = humanoidRootPart.Position
    local targetPos = currentTarget.Position
    

    local myLookVector = humanoidRootPart.CFrame.LookVector
    local myRightVector = Vector3.new(-myLookVector.Z, 0, myLookVector.X).Unit
    

    local targetSidePosition = targetPos + myRightVector * CIRCLE_RADIUS
    

    local offset = targetSidePosition - startPos
    local distance = math.sqrt(offset.X * offset.X + offset.Y * offset.Y + offset.Z * offset.Z)
    local adjustedDuration = distance < CLOSE_RANGE_THRESHOLD and DASH_DURATION_CLOSE or DASH_DURATION
    

    local startCFrame = humanoidRootPart.CFrame
    local goalCFrame = CFrame.new(targetSidePosition) * (startCFrame - startCFrame.Position)
    

    local originalWalkSpeed = humanoid.WalkSpeed
    humanoid.WalkSpeed = 0
    

    local startTime = tick()
    local connection
    
    connection = RunService.Heartbeat:Connect(function()
        local elapsed = tick() - startTime
        local progress = math.min(elapsed / adjustedDuration, 1)
        

        local alpha = 1 - (1 - progress) * (1 - progress)
        

        humanoidRootPart.CFrame = startCFrame:Lerp(goalCFrame, alpha)
        
        if progress >= 1 then
            connection:Disconnect()
            humanoid.WalkSpeed = originalWalkSpeed
            isActive = false
        end
    end)
end

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    if input.KeyCode == Enum.KeyCode.E then
        performSideDash()
    end
end)

player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    humanoid = character:WaitForChild("Humanoid")
    isActive = false
end)

for _, otherPlayer in ipairs(Players:GetPlayers()) do
    setupPlayerTracking(otherPlayer)
end


Players.PlayerAdded:Connect(function(newPlayer)
    setupPlayerTracking(newPlayer)
end)

scanForNPCs()
