-- Humanoid Ghosting (Universal: R6 + R15)
-- Client-side, persistent, players + NPCs
-- Fully self-reapplying (respawn / join / NPC spawn safe)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer
local tracked = {}

-- ===== Utilities =====

local function isLocalCharacter(model)
	return LocalPlayer.Character and model == LocalPlayer.Character
end

local function isValidHumanoidModel(model)
	if not model:IsA("Model") then return false end
	if isLocalCharacter(model) then return false end

	local humanoid = model:FindFirstChildOfClass("Humanoid")
	local hrp = model:FindFirstChild("HumanoidRootPart")

	return humanoid ~= nil and hrp ~= nil
end

local function collectParts(model)
	local parts = {}

	for _, d in ipairs(model:GetDescendants()) do
		if d:IsA("BasePart") then
			parts[#parts + 1] = d
		end
	end

	return parts
end

-- ===== Tracking =====

local function trackModel(model)
	if tracked[model] then return end
	if not isValidHumanoidModel(model) then return end

	tracked[model] = collectParts(model)
end

-- ===== Continuous World Scan (CRITICAL) =====

local function rescanWorld()
	for _, inst in ipairs(Workspace:GetDescendants()) do
		if inst:IsA("Model") then
			trackModel(inst)
		end
	end
end

-- Initial scan
rescanWorld()

-- Periodic rescan to catch EVERYTHING (respawns, rebuilds, late joins)
task.spawn(function()
	while true do
		rescanWorld()
		task.wait(1) -- low cost, very reliable
	end
end)

-- ===== Player Handling =====

local function onCharacterAdded(char)
	task.wait(0.1)
	trackModel(char)
end

local function onPlayerAdded(plr)
	plr.CharacterAdded:Connect(onCharacterAdded)
	if plr.Character then
		onCharacterAdded(plr.Character)
	end
end

Players.PlayerAdded:Connect(onPlayerAdded)

for _, plr in ipairs(Players:GetPlayers()) do
	onPlayerAdded(plr)
end

-- ===== Enforcement Loop (Infinite Yield style) =====

RunService.Stepped:Connect(function()
	for model, parts in pairs(tracked) do
		if not model.Parent then
			tracked[model] = nil
		else
			for i = #parts, 1, -1 do
				local p = parts[i]
				if not p or not p.Parent then
					table.remove(parts, i)
				else
					p.CanCollide = false
				end
			end
		end
	end
end)
